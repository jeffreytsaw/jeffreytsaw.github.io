I"äo<p><a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)">Reflection</a>, specifically type introspection, is an immensely useful feature provided by many modern languages. By enabling a way to inspect the properties of typesâ€”for example, the types of the members of a data structureâ€”introspection allows one to write much more general and effective generic code, enforce interfaces/contracts, and more.</p>

<p>Though most obviously found in dynamic languages, introspection is just as powerful in compiled, statically typed languages such as <a href="https://blog.golang.org/laws-of-reflection">Go</a> and <a href="https://www.youtube.com/watch?v=JoNkttD_MUs">JAI</a>. Unfortunately, C++ does not support run-time reflection as a language feature, and template-based compile-time reflection is neither standardized, elegant, nor robust. Standards proposals have been put forward to add reflection features, but an implementation is still rather far off. Further, <a href="https://github.com/rttrorg/rttr">libraries</a> aiming to provide run-time reflection typically require laborious setup for each type you wish to make reflect-able.</p>

<p>For <a href="https://github.com/TheNumbat/exile">exile</a>, I wanted to use run-time reflection to power truly type-agnostic serialization and UI, but I did not want the code overhead of specifying meta-info for all of my types. Inspired by JAIâ€™s model, I chose to implement a library-level reflection system via meta-programming. Combined with exileâ€™s <a href="https://thenumbat.github.io/Hot-Reloading-in-Exile/">hot reloading system</a>, I find the environment very conducive to iteration and prototypingâ€”even in a very C-like dialect of C++.</p>

<h2 id="usage">Usage</h2>

<p>The end result allowed me to write code such as this, to print any structure:<br />
<em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/engine/ds/string.cpp#L282">Full Implementation</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print_struct</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> 
	
	<span class="kt">uint8_t</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">;</span>
	<span class="n">_type_info</span><span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">TYPEINFO</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

	<span class="n">print</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	
	<span class="n">print</span><span class="p">(</span><span class="sc">'{'</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">print</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">print</span><span class="p">(</span><span class="s">" : "</span><span class="p">);</span>

		<span class="kt">uint8_t</span><span class="o">*</span> <span class="n">member_addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_offsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">_type_info</span><span class="o">*</span> <span class="n">member_type</span> <span class="o">=</span> <span class="n">TYPEINFO_H</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_types</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">print_type</span><span class="p">(</span><span class="n">member_addr</span><span class="p">,</span> <span class="n">member_type</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">print</span><span class="p">(</span><span class="s">", "</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">print</span><span class="p">(</span><span class="sc">'}'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Usage:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">inner</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">10.0</span><span class="n">f</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">outer</span> <span class="p">{</span>
	<span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Data!"</span><span class="p">;</span>
	<span class="n">inner</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">outer</span> <span class="n">o</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
</code></pre></div></div>
<p>Result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>outer{name : "Data!", data : inner{i : 10, f : 10.0}}
</code></pre></div></div>

<h2 id="structure">Structure</h2>

<p>The reflection system relies on a global (thread-local) table that contains all type information. This is a simple hash map that maps from <code class="language-plaintext highlighter-rouge">type_id</code> to <code class="language-plaintext highlighter-rouge">_type_info</code>, which is a discriminated union containing the typeâ€™s size, name, type (that is, integer, floating point, pointer, structure, etc), and associated information, such as member values and names.<br />
<em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/engine/util/type_table.h">Full Implementation</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Type</span> <span class="o">:</span> <span class="kt">uint8_t</span> <span class="p">{</span>
	<span class="n">_void</span><span class="p">,</span>
	<span class="n">_int</span><span class="p">,</span>
	<span class="n">_float</span><span class="p">,</span>
	<span class="n">_ptr</span><span class="p">,</span>
	<span class="n">_struct</span><span class="p">,</span>
	<span class="c1">// ...array, enum, etc...</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Type_void_info</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nc">Type_int_info</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">is_signed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Type_float_info</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nc">Type_bool_info</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nc">Type_ptr_info</span> <span class="p">{</span>
	<span class="n">type_id</span> <span class="n">to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Type_struct_info</span> <span class="p">{</span>
	<span class="n">string</span> 		<span class="n">member_names</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">type_id</span>		<span class="n">member_types</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span>   <span class="o">=</span> <span class="p">{};</span>
	<span class="kt">uint32_t</span> 	<span class="n">member_offsets</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="kt">uint32_t</span> 	<span class="n">member_count</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">_type_info</span> <span class="p">{</span>
	
	<span class="n">Type</span> <span class="n">type_type</span> 	<span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">_void</span><span class="p">;</span>
	<span class="n">type_id</span> <span class="n">hash</span><span class="p">;</span>

	<span class="kt">uint64_t</span> <span class="n">size</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">name</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="n">Type_void_info</span>	 <span class="n">_void</span><span class="p">;</span>
		<span class="n">Type_int_info</span>    <span class="n">_int</span><span class="p">;</span>
		<span class="n">Type_float_info</span>  <span class="n">_float</span><span class="p">;</span>
		<span class="n">Type_bool_info</span>   <span class="n">_bool</span><span class="p">;</span>
		<span class="n">Type_ptr_info</span>    <span class="n">_ptr</span><span class="p">;</span>
		<span class="n">Type_struct_info</span> <span class="n">_struct</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Retrieving the meta-information for a type is straightforward: a <code class="language-plaintext highlighter-rouge">type_id</code> is easily derived from C++â€™s built-in <code class="language-plaintext highlighter-rouge">typeid</code> operator using <code class="language-plaintext highlighter-rouge">hash_code()</code>. Technically, <code class="language-plaintext highlighter-rouge">hash_code()</code> is not guaranteed to never collide, so <code class="language-plaintext highlighter-rouge">std::type_index()</code> is the more robust option. However, I have not had a problem using <code class="language-plaintext highlighter-rouge">hash_code()</code>. Note that because <code class="language-plaintext highlighter-rouge">typeid</code> is only ever used on compile-time known types (that is, not polymorphic objects), this code works properly with <a href="https://www.geeksforgeeks.org/g-fact-33/">RTTI</a> disabled, which I compile without.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...last example...</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">type_id</span><span class="p">,</span><span class="n">_type_info</span><span class="o">&gt;</span> <span class="n">type_table</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">_get_type_info</span> <span class="p">{</span> 
	
	<span class="k">static</span> <span class="n">_type_info</span><span class="o">*</span> <span class="n">get_type_info</span><span class="p">()</span> <span class="p">{</span>

		<span class="k">return</span> <span class="n">type_table</span><span class="p">.</span><span class="n">try_get</span><span class="p">((</span><span class="n">type_id</span><span class="p">)</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">hash_code</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">// get by compile-time type</span>
<span class="cp">#define TYPEINFO(...) _get_type_info&lt; __VA_ARGS__ &gt;::get_type_info()
</span>
<span class="c1">// get by hash</span>
<span class="cp">#define TYPEINFO_H(h) type_table.try_get(h)
</span></code></pre></div></div>

<p>Providing the <code class="language-plaintext highlighter-rouge">TYPEINFO()</code> syntax requires a bit of macro trickery via varargs to group incorrectly comma-delinated template types and a static member function for arbitrary specialization.</p>

<p>Getting information for pointers is slightly more complicated: thereâ€™s no limit on how many different types of pointers that exist, so we canâ€™t populate the table with all of them! Instead, we automatically generate and add a <code class="language-plaintext highlighter-rouge">_type_info</code> when a type of pointer is requested that we havenâ€™t seen before. This is possible because using <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a>, we can extract the pointed-to type of a request, and set our pointer <code class="language-plaintext highlighter-rouge">_type_info</code> to refer to the correct entry in the type table. Because getting the information for an underlying type is a recursive process, this automatically works for multiple indirections: requesting an <code class="language-plaintext highlighter-rouge">int**</code> will create an entry for <code class="language-plaintext highlighter-rouge">int**</code> that refers to a new entry <code class="language-plaintext highlighter-rouge">int*</code> which refers to <code class="language-plaintext highlighter-rouge">int</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...last example...</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">_get_type_info</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="p">{</span>

	<span class="k">static</span> <span class="n">_type_info</span><span class="o">*</span> <span class="n">get_type_info</span><span class="p">()</span> <span class="p">{</span>

		<span class="n">_type_info</span><span class="o">*</span> <span class="n">info</span> <span class="o">=</span> <span class="n">type_table</span><span class="p">.</span><span class="n">try_get</span><span class="p">((</span><span class="n">type_id</span><span class="p">)</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">).</span><span class="n">hash_code</span><span class="p">());</span>
		<span class="k">if</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="k">return</span> <span class="n">info</span><span class="p">;</span>

		<span class="n">_type_info</span><span class="o">*</span> <span class="n">to</span> <span class="o">=</span> <span class="n">TYPEINFO</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

		<span class="n">_type_info</span> <span class="n">ptr_t</span><span class="p">;</span>
		
		<span class="n">ptr_t</span><span class="p">.</span><span class="n">type_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">_ptr</span><span class="p">;</span>
		<span class="n">ptr_t</span><span class="p">.</span><span class="n">hash</span> 		<span class="o">=</span> <span class="p">(</span><span class="n">type_id</span><span class="p">)</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">).</span><span class="n">hash_code</span><span class="p">();</span>

		<span class="n">ptr_t</span><span class="p">.</span><span class="n">size</span> 		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">);</span>
		<span class="n">ptr_t</span><span class="p">.</span><span class="n">name</span> 		<span class="o">=</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		
		<span class="n">ptr_t</span><span class="p">.</span><span class="n">_ptr</span><span class="p">.</span><span class="n">to</span> 	<span class="o">=</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
		
		<span class="k">return</span> <span class="n">type_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ptr_t</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">ptr_t</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Fully built out, along with some utility functions such as enum-stringification and any-width integer load/store, this system is all that is needed to preform very powerful introspection operations. For example, custom UI elements for any type:<br />
<em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/engine/imgui.cpp#L194">Full Implementation</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ImGui</span><span class="o">::</span><span class="n">EditAny</span><span class="p">(</span><span class="s">"cam"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">camera</span><span class="p">);</span>
</code></pre></div></div>
<div style="text-align: center;"><img src="../assets/ui.png" /></div>

<h2 id="metaprogramming">Metaprogramming</h2>

<p>Now, the type table isnâ€™t especially useful if you have to manually populate it with type information. This is where the metaprogramming comes in: instead of relying on a language feature, I wrote a separate program using <a href="https://clang.llvm.org/doxygen/group__CINDEX.html">libclang</a> to automatically generate the code that populates the type table on startup.</p>

<p>libclang is a C binding for LLVMâ€™s clang compiler frontend. While not as powerful as the full C++ interface in <a href="https://clang.llvm.org/docs/LibTooling.html">libtooling</a> or plug-ins for clang itself, it provides enough access to the parsed and type-checked AST for this use case. (See <a href="#limitations">limitations</a>).</p>

<p>The basic structure of the meta-program is quite simple: use libclang to parse the C++ source, traverse the AST to pick out type definitions, and generate the code corresponding to each type. Several complications arise when dealing with dependent types (ordering) and instantiating templates (duplication/dependency info), but for the basic case of ordered C-style structs, everything works intuitively. For brevity, most of the code is not included here.<br />
<em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/tools/meta.cpp">Full Implementation</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">clang_createIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">unit</span> <span class="o">=</span> <span class="n">clang_parseTranslationUnit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s">"path/to/code"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                       <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CXTranslationUnit_KeepGoing</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">clang_getTranslationUnitCursor</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>

<span class="n">clang_visitChildren</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span>
<span class="p">[](</span><span class="n">CXCursor</span> <span class="n">c</span><span class="p">,</span> <span class="n">CXCursor</span> <span class="n">parent</span><span class="p">,</span> <span class="n">CXClientData</span> <span class="n">client_data</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">parse_type</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">CXChildVisit_Recurse</span><span class="p">;</span>

<span class="p">},</span> <span class="nb">nullptr</span><span class="p">);</span>
</code></pre></div></div>

<p>Once a list of types is built from the AST, code is output to a file that is included by the game. The build system typically invokes the meta-program right before compiling the source.<br />
<em>(<a href="../assets/meta_types.cpp">Full Output</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// example output for the "any" struct</span>

<span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
	<span class="n">_type_info</span> <span class="n">this_type_info</span><span class="p">;</span>
	
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">type_type</span> <span class="o">=</span> <span class="n">Type</span><span class="o">::</span><span class="n">_struct</span><span class="p">;</span>
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">any</span><span class="p">);</span>
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"any"</span><span class="n">_</span><span class="p">;</span>
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">type_id</span><span class="p">)</span><span class="k">typeid</span><span class="p">(</span><span class="n">any</span><span class="p">).</span><span class="n">hash_code</span><span class="p">();</span>
	
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TYPEINFO</span><span class="p">(</span><span class="n">type_id</span><span class="p">)</span> <span class="o">?</span> <span class="n">TYPEINFO</span><span class="p">(</span><span class="n">type_id</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"id"</span><span class="n">_</span><span class="p">;</span>
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">any</span><span class="p">,</span><span class="n">id</span><span class="p">);</span>
	
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_types</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">TYPEINFO</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">?</span> <span class="n">TYPEINFO</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"value"</span><span class="n">_</span><span class="p">;</span>
	<span class="n">this_type_info</span><span class="p">.</span><span class="n">_struct</span><span class="p">.</span><span class="n">member_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">any</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
	
	<span class="n">type_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">this_type_info</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">this_type_info</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}();</span>
</code></pre></div></div>

<p>Finally, when the reflection system starts up, it invokes the function output by the meta-program, properly filling out the type table.</p>

<h2 id="limitations">Limitations</h2>

<p><em>In July 2019, the meta-program was rewritten to robustly handle nested templates and circular dependencies.</em></p>

<p>My implementation of the meta-program with libclang is lacking in some areas: the way in which type information is stored prevents circularly dependent types from being output with correct dependencies. Similarly, it cannot decode deeply nested templates. A truly robust implementation would traverse (or rebuild) clangâ€™s representation of the type dependancy graph rather than operating directly from the C++ AST. I plan to upgrade the tool to use libtooling in the future, but the current state is adequate, as the limitations may be worked around. A further upgrade may involve outputting a generic data format that is parsed by the run-time library rather than outputting code that is compiled into the build.</p>

<p>Further, this system does not reflect any OOP concepts such as methods, constructors/destructors, and inheritance, and is hence not really suitable for use with general modern C++. It was made to suit exileâ€™s C-style types with templates, and works accordingly. Such a system for modern C++ is hopefully in the works, and Iâ€™d be exited to play around with it.</p>
:ET