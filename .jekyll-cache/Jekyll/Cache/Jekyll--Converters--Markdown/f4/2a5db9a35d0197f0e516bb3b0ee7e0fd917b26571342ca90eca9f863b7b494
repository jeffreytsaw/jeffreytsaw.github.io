I"≤g<p>No, <a href="https://github.com/TheNumbat/exile">Exile</a> is not technically a ‚Äúvoxel‚Äù engine. A real voxel engine unifies objects, textures, and more into colored voxel data, rendering them via raymarching/<a href="https://en.wikipedia.org/wiki/Marching_cubes">marching cubes</a>/<a href="https://upvoid.com/devblog/2013/05/terrain-engine-part-1-dual-contouring/">dual contouring</a>/etc., and can target realism. Instead, Exile is a ‚Äúvoxel‚Äù engine in that it‚Äôs a traditional 3D engine that happens to focus on representing and drawing textured cubes (like Minecraft and related games). Some have worked around this linguistic confusion by christening the technique <a href="https://yave.handmade.network/">‚ÄúSwedish cubes‚Äù</a>, but for the purposes of this post, please assume that voxels imply textured cubes.</p>

<h2 id="voxels">Voxels</h2>

<p>Representing a game world with voxels provides several distinct advantages:</p>

<p>Interactivity: Voxels provide an obvious way for the player to build, edit, and destroy the world however they wish.</p>

<p>Systems: Having a natural world grid allows procedural generation, NPCs, logistic systems, and the like to seamlessly integrate into the environment.</p>

<p>Performance: Many optimizations (lighting, meshing, AO, culling, pathing, etc.) are available when working with voxel data, resulting in good performance scaling.</p>

<p>Aesthetics: Subjectively, voxel worlds can look better from farther distances than traditional mesh-based worlds, all while being more compact.</p>

<div style="text-align: center;"><img src="../assets/minecraft-shaders.png width=250" /></div>

<p>Of course, voxels are not without some disadvantages:</p>
<ul>
  <li>Not for realism, and can look unnatural when mixed with non-voxel elements.</li>
  <li>No <a href="https://0fps.net/2018/03/03/a-level-of-detail-method-for-blocky-voxels/">natural LOD</a> algorithm (though <a href="http://transvoxel.org/">there is</a> for marching cubes).</li>
  <li>Likely others I haven‚Äôt run into.</li>
</ul>

<p>So voxels are cool, but hasn‚Äôt this already been done by Minecraft, Minetest, Creativerse, FortressCraft, etc? That‚Äôs not even counting the many games that render voxel worlds with a non-cube asethetic. Well, maybe it has, but I believe there‚Äôs work to be done in integrating the technical advancements of a variety of techniques, from user interaction and world generation to new representations and graphics technology.</p>

<p>One of the motivating factors for this project was frustration with the state of modded Minecraft: as complex and interesting as the game can be, it suffers from countless technical problems, performance bottlenecks, and compatibility issues, all of which could be solved under a new platform built with extensibility and performance as top priorities. This is my aspiration for Exile, but the project has also served as a learning experience: deciding to start from absolute scratch has led me to learn about the interconnected workings of everything in a 3D engine, from platform services to data structures to debug interfaces and voxel worlds.</p>

<h2 id="world">World</h2>

<p>In Exile, the world is abstractly represented as an infinite (well, <code class="language-plaintext highlighter-rouge">UINT32_MAX</code> x <code class="language-plaintext highlighter-rouge">UINT32_MAX</code> x 511) field of blocks. Block queries can be made at any position in the world. Of course, there‚Äôs not enough memory on the planet to store that much information, so the world is sparsely populated by 31 x 31 block chunks. When a chunk of the world is needed, for example, because the player is near enough to render it, it is either retrieved from the world (a hash map) or generated and added on-demand.</p>

<p>The following describes Exile‚Äôs general pipeline for going from a flat chunk of voxel data to rendering an output: more detail on how the world is generated, persisted, rendered, and edited will be published in a future post.</p>

<h2 id="techniques">Techniques</h2>

<p>In developing Exile, I explored several techniques for rendering voxel data, and have mostly settled on a hybrid mesh-geometry solution.</p>
<ol>
  <li>
    <p>Instancing</p>

    <p>This technique is the simplest and most obvious: instance a single cube mesh for each block you want to render. This works surprisingly well in the ‚Äúworst‚Äù case, a uniform checkerboard of blocks (meaning all faces must be rendered). However, given the massive overdraw in common cases and lack of flexibility, this technique is not very useful in the end.</p>
  </li>
  <li>
    <p>Geometry shaders</p>

    <p>Using geometry shaders to generate raster data encompasses a variety of options, including <a href="http://jojendersie.de/rendering-huge-amounts-of-voxels/">generating entire blocks</a> (with up to three faces visible) and <a href="https://yave.handmade.network/blogs/p/2629-compact_cube_meshes,_and_compact_cube_meshes_in_unity">generating triangles based on face data</a>. These techniques tend to be the most space-efficient, but suffer in complexity and geometry shader performance.</p>
  </li>
  <li>
    <p>Meshing</p>

    <p>Meshing also refers to several techniques. The basic idea is to generate a traditional 3D mesh from voxel data. Rendering static meshes is just about the fastest thing a GPU can do, so meshing tends to be the most performant approach‚Äîbut can require unacceptable amounts of GPU memory. However, memory limitations may be worked around by using fixed-precision attributes. For example, if all vertices are at integer coodinates within a chunk, the coordinates only need enough bits to cover the size of the chunk‚Äîcertainly not a 12-byte <code class="language-plaintext highlighter-rouge">vec3</code>. Further, this approach can be combined with geometry shaders to render directly from an optimized mesh of per-face data rather than per-vertex data.</p>
  </li>
</ol>

<p>I found the approach with the highest absolute performance to be meshing, settling on a meshing pipeline that works with compact quads: generate an optimized face mesh for each chunk, then feed the mesh faces (each represented by four compact vertices) through an instanced vertex shader that unpacks the vertices, assembles them into a quad, and passes them along to the fragment shader.</p>

<h2 id="meshing">Meshing</h2>

<p>The first step in the voxel rendering pipeline is creating an optimized, render-able mesh from each chunk. This means converting from flat block data to a list of render-able faces. Exile uses a greedy meshing algorithm to both cull invisible faces and combine identical faces into larger blocks, greatly reducing the overall number of quads. Greedy meshing provides a good trade-off between creating compact meshes and latency in (re)generation. I highly recommend reading <a href="https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/">this article</a> for an exploration of the algorithm.</p>

<p><em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/world.cpp#L735">Implementation</a>)</em></p>

<div style="text-align: center;"><img src="../assets/mesh.png" /><p><em>Result of Greedy Meshing</em></p></div>

<h2 id="ambient-occlusion">Ambient Occlusion</h2>

<p>Even without basic lighting, <a href="https://en.wikipedia.org/wiki/Ambient_occlusion">ambient occlusion</a> can provide a reasonable level of definition in corners and facets. Ambient occlusion is very lightweight to implement in a static voxel world: on mesh generation, an occlusion value can be calculated at each vertex and baked into the mesh for the renderer to refer to.</p>

<p>There are four levels of occlusion possible for any vertex in the world, as shown here:</p>

<div style="text-align: center;"><img src="../assets/voxelao.png" /><p><em>Credit <a href="https://0fps.net/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/">0fps.net</a></em></p></div>

<p>Notice that the occlusion value of the vertex is only dependent on the opacity of the three upper adjacent blocks (if all are filled, occlusion is always 0). Hence, for any vertex in the world, one can find which of the four blocks above the vertex is air, then calculate occlusion based on the other three (two sides and the corner). If both sides are filled, the point is maximally occluded, but otherwise, the occlusion is simply increased for each filled block.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">side0</span> <span class="o">&amp;&amp;</span> <span class="n">side1</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">side0</span> <span class="o">-</span> <span class="n">side1</span> <span class="o">-</span> <span class="n">corner</span><span class="p">;</span>
</code></pre></div></div>

<p>Finally, once the 0-3 occlusion value is calculated for each vertex, the fragment shader must use this value to blend and darken the result. To do so, the shader can use the 0-3 value as an index into a uniform occlusion curve, multiplying the fragment color by the specified occlusion factor. In Exile, the default curve is <code class="language-plaintext highlighter-rouge">0.75, 0.825, 0.9, 1.0</code>.</p>

<p>However, simply assigning each vertex an occlusion value and interpolating between them will not produce the correct results over a quad: by default, the GPU will interpolate vertex attributes per triangle in barycentric coordinates. To get around this, we must specify the occlusion values of all four vertices in a face <em>for each vertex</em>. With this information, the fragment shader can interpolate the occlusion bi-linearly based on its texture u/v coordinates, correctly blending occlusion across the quad.</p>

<p><em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/world.cpp#L553">Implementation</a>)</em></p>

<p>For more detail, refer to <a href="https://0fps.net/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/">this article</a>.</p>

<div style="text-align: center;"><img src="../assets/ao.png" /><p><em>With and without ambient occlusion (no other lighting)</em></p></div>

<h2 id="vertex-format">Vertex Format</h2>

<p>Each face output by the meshing system contains four vertices (one for each corner) represented as <code class="language-plaintext highlighter-rouge">uvec2</code>s (eight bytes).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000000000000000000000000000   00000000000000000000000000000000
|------||------||------||------|   |----------||----------||------|
   x       z       v       u            y           id        ao
</code></pre></div></div>

<p>The first <code class="language-plaintext highlighter-rouge">uint</code> contains the x and z positions of the vertex within the chunk, as well as the u and v coordinates for the texture at that vertex. Each value is one byte, hence ranges from 0-255. This is why chunks in Exile are 31 x 31: all x, z, u, and v positions are divided by eight before projection into the world, meaning that we have a range of 0-31.785 blocks, with the option to place a vertex anywhere on a 1/8th block grid.</p>

<p>Unfortunately, because faces are represented by four vertices, one at each corner, 32 x 32 chunks would require vertices with position 32 (256), which is out of range. This problem can be worked around by representing faces as a single vertex and building out the extent of the face in the geometry shader (which I implemented), but the performance/compactness trade-off was not desirable.</p>

<p>Further, you may question why exactly we need to use u/v texture coordinates at all: if everything is just a unit quad, aren‚Äôt all vertices at a u/v endpoint? This is correct, but remember that the greedy meshing system produces quads that can cover up to an entire chunk‚Äî31 x 31‚Äînecessitating a way to signify how many times the single-block texture should be repeated across the combined face.</p>

<p>The second <code class="language-plaintext highlighter-rouge">uint</code> contains the vertex‚Äôs y position (again multiplied by eight), texture ID, and ambient occlusion values. The ID value serves as an index into a texture array containing each block texture‚Äîthe sample coordinate is calculated via <code class="language-plaintext highlighter-rouge">(u / 8, v / 8, t)</code>. Both of these values are 12 bits wide, ranging from 0-4096. Hence, chunks are 511 blocks tall, and the texture array can hold 4096 block textures. (Texture arrays are typically limited to less than 4096 slots, but the highest bits may be used for swapping array ‚Äòbanks.‚Äô)</p>

<p>Finally, the occlusion value is actually four two-bit attributes, representing the 0-3 occlusion values for each vertex in the associated face. Because all four values are represented in each vertex, the fragment shader can use its u/v coordinates to bi-linearly interpolate the occlusion over the quad.</p>

<h2 id="rendering">Rendering</h2>

<p>Once a list of faces, each being four compact vertices, has been generated by the meshing system, it‚Äôs time to pass them to the GPU pipeline. In Exile, they are submitted in an unconventional way: because we want each quad, that is, each sequence of four vertices, to be rendered as its own triangle strip, Exile submits an instanced ‚Äúquad‚Äù to OpenGL for each face. To be specific, Exile draws a four-element triangle strip with an instance for each face. The actual vertex data is gathered from instance-specific attributes describing each vertex of the face. Because there are only four vertices in each (semantic, not actual) draw call, <code class="language-plaintext highlighter-rouge">gl_VertexID</code> may be used to select the current vertex data from the instance attributes. Finally, the vertex shader unpacks the vertex data into floating-point formats, calculates the face normal vector, and submits the data to the fragment shader.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 330 core
</span>
<span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">uvec4</span> <span class="n">v0</span><span class="p">;</span>
<span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span> <span class="kt">uvec4</span> <span class="n">v1</span><span class="p">;</span>

<span class="k">uniform</span> <span class="kt">vec4</span> <span class="n">ao_curve</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">float</span> <span class="n">units_per_voxel</span><span class="p">;</span> <span class="c1">// 8.0</span>

<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">mvp</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">uint</span> <span class="n">x_mask</span>   <span class="o">=</span> <span class="mh">0xff000000u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">z_mask</span>   <span class="o">=</span> <span class="mh">0x00ff0000u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">u_mask</span>   <span class="o">=</span> <span class="mh">0x0000ff00u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">v_mask</span>   <span class="o">=</span> <span class="mh">0x000000ffu</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">uint</span> <span class="n">y_mask</span>   <span class="o">=</span> <span class="mh">0xfff00000u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">t_mask</span>   <span class="o">=</span> <span class="mh">0x000fff00u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">ao0_mask</span> <span class="o">=</span> <span class="mh">0x000000c0u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">ao1_mask</span> <span class="o">=</span> <span class="mh">0x00000030u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">ao2_mask</span> <span class="o">=</span> <span class="mh">0x0000000cu</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint</span> <span class="n">ao3_mask</span> <span class="o">=</span> <span class="mh">0x00000003u</span><span class="p">;</span>

<span class="k">flat</span> <span class="k">out</span> <span class="kt">uint</span> <span class="n">f_t</span><span class="p">;</span>
<span class="k">flat</span> <span class="k">out</span> <span class="kt">vec4</span> <span class="n">f_ao</span><span class="p">;</span>
<span class="k">out</span> <span class="kt">vec2</span> <span class="n">f_uv</span><span class="p">;</span>
<span class="k">out</span> <span class="kt">vec3</span> <span class="n">f_n</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vert</span> <span class="p">{</span>
	<span class="kt">vec3</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">vec2</span> <span class="n">uv</span><span class="p">;</span>
	<span class="kt">vec4</span> <span class="n">ao</span><span class="p">;</span>
	<span class="kt">uint</span> <span class="n">t</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">vec3</span> <span class="nf">unpack_pos</span><span class="p">(</span><span class="kt">uvec2</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kt">vec3</span><span class="p">((</span><span class="n">i</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">x_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">y_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">z_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="n">units_per_voxel</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vert</span> <span class="nf">unpack</span><span class="p">(</span><span class="kt">uvec2</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>

	<span class="n">vert</span> <span class="n">o</span><span class="p">;</span>
	
	<span class="n">o</span><span class="p">.</span><span class="n">pos</span>   <span class="o">=</span> <span class="kt">vec3</span><span class="p">((</span><span class="n">i</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">x_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">y_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">z_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="n">units_per_voxel</span><span class="p">;</span>
	<span class="n">o</span><span class="p">.</span><span class="n">uv</span>    <span class="o">=</span> <span class="kt">vec2</span><span class="p">((</span><span class="n">i</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">u_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">v_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">units_per_voxel</span><span class="p">;</span>
	<span class="n">o</span><span class="p">.</span><span class="n">t</span>     <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">t_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">o</span><span class="p">.</span><span class="n">ao</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao_curve</span><span class="p">[(</span><span class="n">i</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">ao0_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">];</span>
	<span class="n">o</span><span class="p">.</span><span class="n">ao</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao_curve</span><span class="p">[(</span><span class="n">i</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">ao1_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">];</span>
	<span class="n">o</span><span class="p">.</span><span class="n">ao</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao_curve</span><span class="p">[(</span><span class="n">i</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">ao2_mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">];</span>
	<span class="n">o</span><span class="p">.</span><span class="n">ao</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ao_curve</span><span class="p">[(</span><span class="n">i</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">ao3_mask</span><span class="p">)];</span>

	<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

	<span class="kt">uvec2</span> <span class="n">verts</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="kt">uvec2</span><span class="p">[](</span><span class="n">v0</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">v0</span><span class="p">.</span><span class="n">zw</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">zw</span><span class="p">);</span>

	<span class="n">vert</span> <span class="n">v</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="nb">gl_VertexID</span><span class="p">]);</span>

	<span class="kt">vec3</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">unpack_pos</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="kt">vec3</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">unpack_pos</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="kt">vec3</span> <span class="n">v3</span> <span class="o">=</span> <span class="n">unpack_pos</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">mvp</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="n">f_n</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v3</span> <span class="o">-</span> <span class="n">v1</span><span class="p">);</span>
	<span class="n">f_uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
	<span class="n">f_ao</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">ao</span><span class="p">;</span>
	<span class="n">f_t</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The fragment shader then renders the rasterized results using the u/v/t texture coordinates and ambient occlusion values.</p>

<h2 id="next">Next</h2>

<p>In Voxel Rendering Part 2, I will cover the systems for custom block models, lighting, and animations. But first, look out for environment rendering and world representation!</p>
:ET