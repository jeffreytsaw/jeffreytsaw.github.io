I"Û]<p>In game development, one of the main draws of implementing game logic in a scripting language like Lua is the convenient ability to make changes to the source, reload the logic on the fly, and test the changes without restarting the game. A similar technique is also often used to refresh shader programs, asset files, and the like.</p>

<p>However, supporting a secondary scripting language‚Äîor using one from the start‚Äîis not the only way to implement such a system. While more complicated, implementing the ability to reload code on a binary level allows one to make potentially deep changes to the entire source and have them appear instantly. Further, any language that can export C ABI compatible functions can be dynamically loaded in this manner, using good old-fashioned dynamic link libraries/shared objects.</p>

<p>I used this technique to implement hot-reloading the full C++ source of <a href="https://github.com/TheNumbat/exile">Exile</a>. The system provides many benefits, such as fast and convenient gameplay iteration, a clear platform-specific code boundary, and centralized state. This post focuses on the several caveats I had to work around, but I have still found maintaining the system to be worthwhile and educational.</p>

<video src="../assets/reload.mp4" preload="" autoplay="" muted="" loop="" style="max-width: 100%; margin: 0 auto;"></video>

<h2 id="structure">Structure</h2>

<p>The actual implementation in <a href="https://github.com/TheNumbat/exile">Exile</a> is somewhat more complicated than described here, due to supporting multiple platforms and solving the issues below. This post intends to present the basic structure of the technique.</p>

<p>Running a re-loadable binary follows three basic steps:</p>
<ol>
  <li>Load the dynamic code and its start-up, loop, and shut-down functions. Call start-up.</li>
  <li>Enter the main loop. Call loop. After each iteration, check if the library file has been overwritten. If so, reload the library and its control functions.</li>
  <li>On quit, call shut-down and unload the library.</li>
</ol>

<p>For example, on windows, the library API would be written as such:<br />
<em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/engine/engine.cpp">Full Implementation</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "platform_api.h"
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>

    <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="kt">void</span><span class="o">*</span> <span class="n">start_up</span><span class="p">(</span><span class="n">platform_api</span><span class="o">*</span> <span class="n">api</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// allocate/initialize state...</span>

        <span class="k">return</span> <span class="n">state</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="kt">bool</span> <span class="n">main_loop</span><span class="p">(</span><span class="n">engine</span><span class="o">*</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// run frame...</span>

        <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">is_running</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="kt">void</span> <span class="n">shut_down</span><span class="p">(</span><span class="n">engine</span><span class="o">*</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// destroy/free state...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And the main executable:<br />
<em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/engine/platform/platform_main.cpp">Full Implementation</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;windows.h&gt;
#include "platform_api.h"
</span>
<span class="k">typedef</span> <span class="kt">void</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">start_up_t</span><span class="p">)(</span><span class="n">platform_api</span><span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">bool</span>  <span class="p">(</span><span class="o">*</span><span class="n">main_loop_t</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">void</span>  <span class="p">(</span><span class="o">*</span><span class="n">shut_down_t</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>

<span class="n">HANDLE</span> <span class="n">library</span><span class="p">;</span>

<span class="n">start_up_t</span>  <span class="n">start_up</span><span class="p">;</span>
<span class="n">main_loop_t</span> <span class="n">main_loop</span><span class="p">;</span>
<span class="n">shut_down_t</span> <span class="n">shut_down</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">load_library</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">library</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="s">"path/to/game.dll"</span><span class="p">);</span>

    <span class="n">start_up</span>  <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">library</span><span class="p">,</span> <span class="s">"start_up"</span><span class="p">);</span>
    <span class="n">main_loop</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">library</span><span class="p">,</span> <span class="s">"main_loop"</span><span class="p">);</span>
    <span class="n">shut_down</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">library</span><span class="p">,</span> <span class="s">"shut_down"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_library</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">FreeLibrary</span><span class="p">(</span><span class="n">library</span><span class="p">);</span>
    <span class="n">start_up</span> <span class="o">=</span> <span class="n">main_loop</span> <span class="o">=</span> <span class="n">shut_down</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">load_library</span><span class="p">();</span>

    <span class="n">platform_api</span> <span class="n">api</span><span class="p">;</span>

    <span class="kt">void</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="n">start_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">api</span><span class="p">);</span>

    <span class="n">WIN32_FILE_ATTRIBUTE_DATA</span> <span class="n">attribs</span><span class="p">;</span>
    <span class="n">GetFileAttributesEx</span><span class="p">(</span><span class="s">"path/to/game.dll"</span><span class="p">,</span> <span class="n">GetFileExInfoStandard</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">attribs</span><span class="p">);</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">main_loop</span><span class="p">(</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>

        <span class="n">WIN32_FILE_ATTRIBUTE_DATA</span> <span class="n">new_attribs</span><span class="p">;</span>
        <span class="n">GetFileAttributesEx</span><span class="p">(</span><span class="s">"path/to/game.dll"</span><span class="p">,</span> <span class="n">GetFileExInfoStandard</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">new_attribs</span><span class="p">);</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">CompareFileTime</span><span class="p">(</span><span class="n">attribs</span><span class="p">.</span><span class="n">ftLastWriteTime</span><span class="p">,</span> 
                           <span class="n">new_attribs</span><span class="p">.</span><span class="n">ftLastWriteTime</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

            <span class="n">free_library</span><span class="p">();</span>
            <span class="n">load_library</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">attribs</span> <span class="o">=</span> <span class="n">new_attribs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">shut_down</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>

    <span class="n">free_library</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And voil√†! You have hot reloading‚Ä¶in principle. While this structure is all that is needed to support swapping out old and new code, there are several more problems to solve.</p>

<h2 id="memory">Memory</h2>

<p>If you‚Äôre familiar with the semantics of loading/freeing dynamic library objects, you may be concerned about what happens to memory allocated by our library when we reload it‚Äîit disappears. When a library is unloaded, its memory is removed from the address space of the process that loaded it. This means that we can‚Äôt depend on any library-owned memory, including both globals/statics and heap allocations.</p>

<p>Hence, there are two ways to access the heap in a persistent manner:</p>
<ol>
  <li>Virtually preallocate a very large block of memory in the main executable and pass it to the library. The library can then use a custom allocator to slice up the block.</li>
  <li>Expose the main executable‚Äôs memory allocation functions to the library via the platform API. For example, this could mean including pointers to malloc and free.</li>
</ol>

<p>Either way, one still can‚Äôt depend on global or static variables having persistent values. This, at least, can be worked around in code.</p>

<p>In exile, I chose the second option, as it meshed well with my platform abstraction approach: passing a structure of platform abstracted function pointers from the main executable to the (platform-agnostic) library. However, the first option provides more flexibility and potentially more performance, as one can choose an allocator tuned for their use case (including profiling features), and each allocate/free does not have to go through a pointer indirection. For these reasons, I intend to switch exile‚Äôs approach in the future.</p>

<h2 id="threads">Threads</h2>

<p>When the library is unloaded, threads it created are not terminated. This is not good: the memory for each thread‚Äôs stack frame and any thread-local storage is associated with the library, and is invalidated when it is freed! Because of this, if our library creates threads, they must be terminated and restarted before and after each dynamic reload. To implement this we can simply add <code class="language-plaintext highlighter-rouge">begin_reload</code> and <code class="language-plaintext highlighter-rouge">end_reload</code> functions to our library API and call them from the main executable appropriately. Unfortunately, this does mean that each thread must complete the currently running (atomic) task before the reload can take place, leading to possible slowdowns when reloading.</p>

<h2 id="function-pointers">Function Pointers</h2>

<p>Persistently storing function pointers significantly limits the type of changes that can be reloaded successfully. This is because if the patched library contains new, different, or less functions than the previous version, their relative locations in its address space may change. And that means that previously stored function pointers are invalidated. On the other hand, taking addresses of functions on a per-frame basis, for example, passing a function to a generic sort, always works correctly, because the new function address is already patched into the code.</p>

<p>There are another two ways to fix this:</p>
<ol>
  <li>Don‚Äôt use persistent function pointers.</li>
  <li>Store pointers only to exported functions in conjunction with their name. Reload them when the library is reloaded.</li>
</ol>

<p>The first option is viable, and forces one to limit ‚Äúvirtual‚Äù indirection, but in exile, I decided to use the second option. This is because I thought the flexibility and extensibility of function pointers, especially for a future modding API, was worth the extra indirection. To implement the second option, exile stores function pointers as typed callable objects referencing a global table of raw address-and-name pairs. When the library is reloaded, the engine simply reloads each function from itself. Still, without much more invasive patching, C++ virtual functions cannot be used on objects that persist between reloads.</p>

<p>Simplified implementation:<br />
<em>(<a href="https://github.com/TheNumbat/exile/blob/master/src/engine/util/fptr.h">Full Header</a> | <a href="https://github.com/TheNumbat/exile/blob/master/src/engine/util/fptr.cpp">Full Implementation</a>)</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">_FPTR</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">func_ptr_state</span> <span class="p">{</span>

    <span class="n">_FPTR</span> <span class="n">all_ptrs</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
    <span class="n">u32</span> <span class="n">num_ptrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">args</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">func_ptr</span> <span class="p">{</span>

    <span class="n">func_ptr</span><span class="p">(</span><span class="n">_FPTR</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">;}</span>

    <span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="n">args</span><span class="p">...</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">return</span> <span class="p">((</span><span class="n">T</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">args</span><span class="p">...))</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">)(</span><span class="n">arg</span><span class="p">...);</span>
    <span class="p">}</span>

    <span class="n">_FPTR</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">func_ptr_state</span><span class="o">*</span> <span class="n">global_func</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>

<span class="n">_FPTR</span><span class="o">*</span> <span class="nf">get_func_ptr</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">func</span><span class="p">,</span> <span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">for</span><span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">global_func</span><span class="o">-&gt;</span><span class="n">num_ptrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">global_func</span><span class="o">-&gt;</span><span class="n">all_ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">func</span> <span class="o">==</span> <span class="n">func</span><span class="p">)</span>  <span class="p">{</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">global_func</span><span class="o">-&gt;</span><span class="n">all_ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">u32</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">global_func</span><span class="o">-&gt;</span><span class="n">num_ptrs</span><span class="p">;</span>
    <span class="n">global_func</span><span class="o">-&gt;</span><span class="n">num_ptrs</span><span class="o">++</span><span class="p">;</span>

    <span class="n">global_func</span><span class="o">-&gt;</span><span class="n">all_ptrs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">global_func</span><span class="o">-&gt;</span><span class="n">all_ptrs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="n">global_func</span><span class="o">-&gt;</span><span class="n">all_ptrs</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reload_func_ptrs</span><span class="p">(</span><span class="n">platform_dll</span> <span class="n">this_dll</span><span class="p">)</span> <span class="p">{</span> 

    <span class="k">for</span><span class="p">(</span><span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_ptrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">get_proc_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_func</span><span class="o">-&gt;</span><span class="n">all_ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">func</span><span class="p">,</span> <span class="n">this_dll</span><span class="p">,</span> 
                          <span class="n">global_func</span><span class="o">-&gt;</span><span class="n">all_ptrs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Usage:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">func_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="n">get_func_ptr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s">"func"</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="string-literals">String Literals</h2>

<p>String literals are subject to the same limitations as function pointers: since they are stored in static memory (.rodata), their addresses may change when the library is reloaded. This is relatively easy to work around by not storing pointers to string literals. Instead, either initialize/pass the literals every frame, or make heap-allocated copies for storage.</p>

<h2 id="struct-layouts">Struct Layouts</h2>

<p>The last limitation of simple binary reloading is the most difficult to resolve: the conflict between old data and new code that expects a different format. Issues of this nature can be triggered whenever a reload changes the size of a structure‚Äîfor example, a previously allocated array of those structures is now all out of alignment, leading to difficult-to-debug crashes. In exile, I‚Äôve chosen to live with this limitation: reloading is, mostly, most of the time, primarily useful for tweaking existing code without the need to alter data structures. However, if an in-memory update is every truly needed, code to migrate the memory to a new format can just be dynamically patched in and run on reload.</p>

<p>Solving this problem in a general fashion involves serializing all persistent state on unload, and deserializing it into the new format on load. This is achievable using the <a href="https://thenumbat.github.io/Reflection-in-Exile/">reflection framework</a> I have also implemented in exile, but I have not found it necessary as of yet.</p>

<h2 id="self-modifying-code">Self-Modifying Code</h2>

<p>This framework for dynamically reloading C++ can be straightforward to implement, but has a few significant limitations. A more complex method of live binary patching‚Äîwithout reloading‚Äîsuch as used in <a href="https://molecular-matters.com/products_livepp.html">Live++</a>, combined with full serialization, could solve all of the problems, but is not so trivial to implement oneself.</p>
:ET